[정규 표현식 살펴보기]
- 정규 표현식은 왜 필요한가?

[정규 표현식 시작하기]
- 정규 표현식의 기초, 메타 문자
# []문자 -문자 클래스
# .[dot]문자 -\n을 제외한 모든 문자
# *문자
# +문자
# {}문자와 ?문자

- 파이썬에서 정규 표현식을 지원하는 re모듈
import re
p = re.compile('ab*')

- 정규식을 이용한 문자열 검색
import re
p = re.compile('[a-z]+')

# match
m = p.match("python")
print(m)
m = match("3 python")
print(m)

# search
m = p.serach("python")
print(m)

m = p.search("3 python")
print(m)

# findall
result = p.findall("life is too short")
print(result)

# finditer
result = p.finditer("life is too short")
print(result)
for r in result: print(r)

- match 객체의 메서드
m = p.match("python")
m.group()
m.start()
m.end()
m.span()

m = p.search("3 python")
m.group()
m.start()
m.end()
m.span()

- 컴파일 옵션
# DOTALL, S
import re
p = re.compile('a.b')
m = p.match('a\nb')
print(m)

p = re.compile('a.b', re.DOTALL)
m = p.match('a\nb')
print(m)

# IGNORECASE, I
p = re.compile('[a-z]+', re.I)
p.match('python')
p.match('Python')
p.match('PYTHON')

# MULTILINE, M
import re
p = re.compile("^python\s\w+")

data = """python one
life is too short
python two
you need python
python three"""

print(p.findall(data))


import re
p = re.compile("^python\s\w+", re.MULTILINE)

data = """python one
life is too short
python two
you need python
python three"""

print(p.findall(data))

#VERBOSE

- 역슬래시 문제
\section
[ \t\n\r\f\v]ection
\\section


[강력한 정규 표현식의 세계로]
- 문자열 소비가 없는 메타 문자
# |
p = re.compile('Crow:Servo')
m = p.match('CrowHello')
print(m)

# ^
print(re.search('^Life', 'Life is too short'))
print(re.search('^Life', 'My Life'))

# $
print(re.search('short$', 'Life is too short'))
print(re.search('short$', 'Life is too short, you need python'))

# \A
# \Z
# \b
p = re.compile(r'\bclass\b')
print(p.search('no class at all'))
print(p.search('the declassified algorithm'))
print(p.search('one subclass is'))

# \B
p = re.compile(r'\Bclass\B')
print(p.search('no class at all'))
print(p.search('the declassified algorithm'))
print(p.search('one subclass is'))

- 그루핑
p = re.compile('(ABC)+')
m = p.search('ABCABCABC OK?')
print(m)
print(m.group())

p = re.compile(r"\w+\s+\d+[-]\d+[-]\d+")
m = p.search("park 010-1234-1234")

print(m.group(1))
print(m.group(2))
print(m.group(3))

# 그루핑된 문자열 재참조하기
p = re.compile(r'(\b\w+)\s+\1')
p.search('Paris in the the spring').group()

#그루핑된 문자열에 이름 붙이기
p = re.compile(r"(?P<name>\w+)\s+((\d+)[-]\d+[-]\d+)")
m = p.search("park 010-1234-1234")
print(m.group("name"))

p = re.compile(r'(?P<word>\b\w+)\s+(>P=word)')
p.search('Paris in the spring').group()

- 전방 탐색
p = re.compile(".+:")
m = p.search("http://google.com")
print(m.group())

# 긍정형 전방 탐색

