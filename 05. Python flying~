#클래스
class Calculator:
  def __init__(self):
    self.result = 0
  def add(self, num):
    self.result += num
    return self.result

cal1 = Calculator()
cal2 = Calculator()

print(cal1.add(3))
print(cal2.add(3))

#사칙연산 클래스 만들기
a = FourCal()
a = setdata(4,2) #4와 2를 a에 저장

a.add() #덧셈
a.mul() #곱
a.sub() #뺄셈
a.div() #나누기

class FourCal:
  def setdata(self, first, second):
      self.first = first
      self.second = second

a.setdata(4, 2)
a.frist

#더하기 기능 만들기
class FourCal:
  def setdata(self, first, second):
      self.first = first
      self.second = second
  def add(self):
      result = self.first + self.second
      return result

a = FourCal()
a.setdata(4,2)
a.add()

#곱하기, 빼기, 나누기 기능 만들기
class FourCal:
  def setdata(self, first, second):
      self.first = first
      self.second = second
  def add(self):
      result = self.first + self.second
      return result
  def add(self):
      result = self.first * self.second
      return result
  def add(self):
      result = self.first - self.second
      return result
  def add(self):
      result = self.first / self.second
      return result

a = FourCal()
b = FourCal()
a.setdata(4, 2)
b.setdata(3, 8)

#생성자 : 객체가 생성될 때 자동으로 호출되는 메서드를 의미
class FourCal:
  def __init__(self, first, second):
      self.first = first
      self.second = second
*__init__메서드는 setdata 메서드와 이름만 다르고 모든 게 동일하다

#클래스의 상속
class MoreFourCal(FourCal):
  pass

a = MoreFourCal(4,2)
a.add() #상속받은 FourCal 클래스의 기능을 모두 사용할 수 있다
a.mul()
a.sub()
a.div()

class MoreFourCal(FourCal):
  def pow(self):
    result = self.first ** self.second
    return result

a = MoreFourCal(4,2)
a.pow()

#메서드 오버라이딩
- 부모 클래스에 있는 메서드를 동일한 이름으로 다시 만드는 것
class SafeFourcal(FourCal):
  def div(self):
    if self.second == 0:
      return 0
    else:
      return self.first/self.second

a = SafeFourCal(4, 0)
a.div()

#클래스 변수
class Family:
  lastname = '김'

Family.lastname

- 클래스변수는 객체변수와 달리 클래스로 만든 모든 객체에 공유된다는 특징이 있다
*클래스변수와 동일한 이름의 객체변수를 생성하면?


[모듈]
- 파일 mod1.py를 만들고 디렉터리에 저장 -> mod1.py 파일이 바로 모듈이다

#모듈 불러오기
- 명령 프롬프트 창을 열고 mod1.py를 저장한 디렉터리로 이동한 후 대화형 인터프리터를 실행

import mod1
print(mod1.add(3, 4))
print(mod1.sub(4, 2))
- import는 이미 만들어 놓은 파이썬 모듈을 사용할 수 있게 해 주는 명령어이다
import 모듈_이름
from 모듈_이름 import 모듈_함수

from mod1 import add
from mod1 inport add, sub
from mod1 import *           #mod1 모듈의 모든 함수를 불러와 사용하겠다는 뜻

# if__name__=="__main__":의 의미
if__name__=="__main__"을 사용하면 직접 파일을 실행했을 때는 __name__=="__main__"이 참이 되어 if문 다음 문장이 수행된다

#클래스나 변수 등을 포함한 모듈
PI = 3.141592

class Math:
  def solv(self, r):
    return PI * (r ** 2)

def add(a, b):
  return a + b

#다른 파일에서 모듈 불러오기
import mod2
result = mod2.add(3,4)
print(result)
*위 예제가 정상적으로 실행되기 위해서는 modtest.py 파일과 mod2.py 파일이 동일한 디렉터리에 있어야 한다

#다른 디렉터리에 있는 모듈을 불러오는 방법
#sys.path.append 사용하기
import sys #파이썬 라이브러리가 설치되어 있는 디렉터리를 확인할 수 있다
sys.path #디렉터리 목록을 보여준다
sys.path.append("C:/doit/mymod")
sys.path

import mod2
print(mod2.add(3,4))

#PYTHONPATH 환경 변수 사용하기
C:\doit>set PYTHONPATH=C:\doit\mymod
C:\doit>python
import mod2
print(mod2.add(3,4))
